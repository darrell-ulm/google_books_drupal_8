<?php
/**
 * @file
 * 7.0 Darrell Ulm
 *
 *
 */

//Implementation of hook_filter_tips
/**
 * Filter tips callback function for $filters[0] in hook_filter_info().
 */
function filter_googlebook_tips($filter, $format, $long = FALSE) {
  if ($long) {
    return t('Placing an 10 or 13-digit ISBN or Open Library ID between curly braces, {{0312305389}}, will return book information and cover from the Open Library');
  }
}

/**
 * Implements hook_filter_info().
*/
function googlebook_filter_info() {
  $filters['googlebook'] = array(
    'title' => t('Google Book'),
    'description' => t('Insert Book Information from Google'),
    'process callback' => 'googlebook_filter_process',
    'settings callback' => 'googlebook_filter_settings',
    'default settings' => array(
      'worldcat' => 1,
      'googlebooks' =>  1,
      'librarything' => 1,
      'bib_fields' => bib_field_array()
    ),
    'tips callback' => 'filter_googlebook_tips',
  );
  return $filters;
}

//Implementation of hook_filter
function googlebook_filter_process($text, $filter, $format, $langcode, $cache, $cache_id) {
      preg_match_all('/{{(.*)}}/', $text, $match);
      $tag = $match[0];
      $book = array();
      $counter = 0;
      for ($i = 0; $i < count($match[1]); $i++) {
        $book[$counter] = retrieve_bookdata($match[1][$i], $filter->settings['worldcat'], $filter->settings['librarything']
                ,$filter->settings['googlebooks'], $filter->settings['bib_fields'] );
        $counter++;
      }
      $text = str_replace($tag, $book, $text);
      return $text;
}

// implementation of googlebook filter settings
function googlebook_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {

      $settings['googlebook'] = array(
        '#type' => 'fieldset',
        '#title' => t('Google Book Filter'),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
      );
      $settings['bib_fields'] = array(
      '#type' => 'select',
      '#multiple' => TRUE,
      '#title' => 'Book Data Fields to Use',
      '#required' => TRUE,
      '#options' => bib_field_array(),
      //'#default_value' => isset($filter->settings['bib_fields']) ? $filter->settings['bib_fields'] : $defaults['bib_fields'],
      '#default_value' => isset($filter->settings['bib_fields']) ? $filter->settings['bib_fields'] : bib_field_array()
      );
      $settings['worldcat'] = array(
        '#type' => 'checkbox',
        '#title' => t('Link to WorldCat'),
        '#default_value' => isset($filter->settings['worldcat']) ? $filter->settings['worldcat'] : $defaults['worldcat'],
      );
      $settings['librarything'] = array(
        '#type' => 'checkbox',
        '#title' => t('Link to LibraryThing'),
        '#default_value' => isset($filter->settings['librarything']) ? $filter->settings['librarything'] : $defaults['librarything'],
      );
      $settings['googlebooks'] = array(
        '#type' => 'checkbox',
        '#title' => t('Link to Google Book Search'),
        '#default_value' => isset($filter->settings['googlebooks']) ? $filter->settings['googlebooks'] : $defaults['googlebooks'],
      );
      return $settings;
}


//this method replaces file_get_contents, which is sometimes disallowed on servers
function get_url_contents($url, $curltimeout) {

  // Establish a cURL handle.
  $ch = curl_init($url);

  // Set our options
  curl_setopt($ch, CURLOPT_HEADER, FALSE); //false=do not include headers
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE); //true=return as string
  curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $curltimeout); //timeout for when OL is down
  curl_setopt($ch, CURLOPT_TIMEOUT, $curltimeout); //timeout for when OL is down

  // Execute the request
  $output = curl_exec($ch);

  // Close the cURL session.
  curl_close($ch);

  if ($output == "") {
    throw new Exception("Open Library Data Unavailable");
  }
  return $output;
}


/*  function retrieve_bookdata()
 *  Gets the book data from Google Books / other sites and then displays it.
 *  $id is an Google Book code or ISBN
 */
function retrieve_bookdata($id, $worldcat_op, $librarything_op, $googlebooks_op, $bib_field_select) {

    //      Get the correct Open Library bib record fields selected
   //  $bib_fields = array_intersect_key( bib_field_array(), $bib_field_select );

    $bib_fields = bib_field_array();

    // set some variables
    $curltimeout = 10;                    // timeout for the openlibrary curl call
    $path = '../' . drupal_get_path('module', 'googlebook');
    $html_bookdata = "";
    $html_text = "";
    $title = "";
    $html_coverimage = "";
    $html_fields = "";

    $isbn = $id;
    //clean ISBN of dashes and spaces, add more as needed
    $dirt_isbn = array("-", " ");
    $isbn = str_replace($dirt_isbn, "", $isbn);

    $url_bookkeys = "https://www.googleapis.com/books/v1/volumes?q=" . $isbn ;
    $bookkeys = get_url_contents($url_bookkeys, $curltimeout);
    $obj = json_decode($bookkeys, TRUE);

    $versions = $obj['totalItems'];

    if ( $versions > 0 ) {
        $bookkeyresult = $obj['items'][0];  // grab the results if there
        $version = 0;

        $barr =  $bookkeyresult;
        $book_str = json_extract($barr); // extract the results

        // Build array for this
        $bib = array();
        $fields = explode("|||", $book_str);
        for ( $i = 1; $i < count( $fields ); $i += 2 ) {
                $fieldname = $fields[ $i ];

                if ( strpos( $fields[ $i + 1 ], "[[[" ) === FALSE ) {
                    $value = trim( str_replace( "(((", "", $fields[ $i + 1 ]) );
                }
                else {
                    $sub_value = "";
                    $sub_fields = explode( "[[[", $fields[ $i + 1 ] );
                    for ( $j = 1; $j < count( $sub_fields ); $j += 2 ) {
                        if ( $j != 1 && ! empty( $sub_fields[ $j + 1 ] ) ) {
                            $sub_value .= " | ";
                        }
                        $sub_value .= trim( str_replace( "(((", "", $sub_fields[ $j + 1 ] ) );
                    }
                    $value = $sub_value;
                }
                if ( ! empty($value) ) {
                    assign_bib_array( & $bib, $fieldname, $value );
                }
            }

        $html_fields .= "<ul>";
        foreach ( $bib_field_select as $i => $k ) {
            $field = $bib_fields[ $i ];
            $field_val = "";
            if ( isset( $bib [ $field ] ) ) {
                $field_val = $bib [ $field ];
            }
            if ( ! empty( $field_val ) ) {
                $html_fields .= "<li class='googlebook_". $field . "'><span class='googlebook_name'>".  ucfirst ( preg_replace('/[A-Z]/', ' $0', str_replace('_', ' ', $field) ) ) . ": </span><span class='googlebook_data'>" . make_html_link( $field_val ) . "</span></li>";
            }
        }
        $html_fields .= "</ul>";

        //title
        $title = $bib['title'];
        $html_title = '<p>Title: <a href="' . $bib['infoLink'] . '" rel="nofollow" target="_blank"><i>' . $title . '</i></a></p>';

        //coverimage
        if ( isset($bib['thumbnail']) ) {
            $html_coverimage = "<img src='" . $bib['thumbnail'] . "' alt='" . $title . "' />";
            $html_coverimage = "<p><a style='float:right' class='googlebook_image' href='" . $bib['infoLink'] . "' rel='nofollow' target='_blank'>" . $html_coverimage . "</a></p>";
        }

       $html_text .= $html_title;
       $html_text .= $html_fields;

       //div whole class for themeing
       $html_bookdata = '<div class="googlebooks" >' . $html_coverimage . $html_text . '<div style="clear:both;"></div></div>';
       } 

  return $html_bookdata;
}


// Get the JSON into something we can display
// Pass by reference to speed up recursion. 
function json_extract(& $barr) {
    $bib_fields = bib_field_array();
    $book_html = "";
    // loop through array struture recursively
    foreach ($barr as $key => $value) {
  //      if ( /*in_array($key,$bib_fields) ||*/ TRUE || is_int($key) ) {
            if ( ! is_array($value) && $value != ""  ) {
                $effective_key = is_int($key) ? '[[[///'.$key.'[[[' : '|||'.$key.'|||';
                $book_html .= "$effective_key ((($value(((";
            }
            else {
                if ( is_array( $value ) ) {
                    $sub_bib = json_extract($value, $bib_fields);
                }
                else {
                    $sub_bib = $value;
                }
                if ( $sub_bib != "" ) {
                        $book_html .= "|||".$key."|||".$sub_bib."";
                }
            }
   //     }
    }
    return $book_html;
}


// Get a bib value from the string
function extract_from_string_by_key( $bib_str, $find ) {
   $field_arr = explode("|||", $bib_str);
   $found_index = array_search($find, $field_arr);
   if ( $found_index === FALSE ) {
       return FALSE;
   }
   $found_str = $field_arr[ $found_index + 1 ];
   return str_replace("(((", "", $found_str);
}

// If the bib field looks like an address, make it a link
function make_html_link( $address ) {
    if ( strpos($address, "https://") !== FALSE || strpos($address, "http://") !== FALSE ) {
        return '<a href="' . $address . '" rel="nofollow" target="_blank">' . $address . '</a>';
    }
return $address;
}


function assign_bib_array( & $bib_array, $index, $value ) {
    if ( ! array_key_exists( $index, $bib_array ) ) {
        $bib_array[ $index ] = $value;
    }
    else {
        $bib_array[ $index ] = $bib_array[ $index ] . " | " . $value;
    }
}


// These are the fields that are in the multi select list
function bib_field_array()
{
   return array
   (
       'kind',
       'id',
       'etag',
       'selfLink',
       'volumeInfo',
       'title',
       'authors',
       'publisher',
       'publishedDate',
       'description',
       'industryIdentifiers',
       'type',
       'identifier',
       'pageCount',
       'dimensions',
       'height',
       'width',
       'thickness',
       'printType',
       'mainCategory',
       'categories',
       'averageRating',
       'ratingsCount',
       'contentVersion',
       'imageLinks',
       'smallThumbnail',
       'thumbnail',
       'small',
       'medium',
       'large',
       'extraLarge',
       'language',
       'previewLink',
       'infoLink',
       'canonicalVolumeLink',
       'saleInfo',
       'country',
       'saleability',
       'isEbook',
       'accessInfo',
       'viewability',
       'embeddable',
       'publicDomain',
       'textToSpeechPermission',
       'epub',
       'acsTokenLink',
       'accessViewStatus'
   );
}
