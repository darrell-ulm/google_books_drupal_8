<?php
/**
 * @file
 * Googlebook API Module 
 *    for Drupal 7.0
 *
 * Copyright 2011 Darrell Ulm.
 *
 * Based initialy on the BookPost module for Drupal 6 by Aaron Rubinstein,
 *   and partially based on the the OpenLibrary API for Drupal 6
 *
 * The Google Book search can be done with many types of search strings.
 *
 * There are many search options with Google books. See
 * books.google.com documation for more information
 *
 * See the INSTALL.TXT file for specific information.
 *
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

define("CURLTIMEOUT", 10);
define("GOOGLE_BOOKS_API_ROOT", 'https://www.googleapis.com/books/v1/volumes?q=');
define("OPENLIBRARY_CACHE_PERIOD", 24 * 60 * 60 ); // in secs

/* Function: bib_field_array()
 * 
 * These are the fields that are in the multi select list and are
 * displayable in google books. Just returns an array.
 * 
 */
function bib_field_array() {
   return array
   (
       'kind',
       'id',
       'etag',
       'selfLink',
       //'volumeInfo',
       'title',
       'authors',
       'publisher',
       'publishedDate',
       'description',
       //'industryIdentifiers',
       'type',
       'identifier',
       'pageCount',
       //'dimensions',
       'height',
       'width',
       'thickness',
       'printType',
       'mainCategory',
       'categories',
       'averageRating',
       'ratingsCount',
       'contentVersion',
       //'imageLinks',
       'smallThumbnail',
       'thumbnail',
       'small',
       'medium',
       'large',
       'extraLarge',
       'language',
       'previewLink',
       'infoLink',
       'canonicalVolumeLink',
       //'saleInfo',
       'country',
       'saleability',
       'isEbook',
       //'listPrice',
       'amount',
       'currencyCode',
       'buyLink',
       //'accessInfo',
       'viewability',
       'embeddable',
       'publicDomain',
       'textToSpeechPermission',
       'epub',
       //'acsTokenLink',
       'accessViewStatus'
   );
}



/*  Function: get_googlebook_data()
 *
 *  Gets the book data from Google Books
 *  $id is a valid Google Book query.
 *
 *  Puts all results in a flat array, key = field name.
 *
 *  Multiple data fields are delimited by '|' character in string
 *
 */
function get_googlebook_data( $id ) {

    //clean search string of spaces, turn into '+'
    $dirt_id = array(" ");
    $id = str_replace( $dirt_id, "+", $id );

    // $url_bookkeys = GOOGLE_BOOKS_API_ROOT . $id ;
    // $bookkeys = get_url_contents($url_bookkeys, CURLTIMEOUT);
    $bookkeys = _googlebook_cached_request( $id );
    
    // Decode into array to be able to scan
    $obj = json_decode($bookkeys, TRUE);

    $versions = $obj['totalItems'];

    // Check the number of versions returned by Google Books
    if ( $versions > 0 ) {

        $bookkeyresult = $obj['items'][0];  // Grab the first result

        // extract the results into one big string with delimiters
        $book_str = json_extract($bookkeyresult); 

        // Build array for this
        $bib = array();
        $fields = explode("|||", $book_str);
        for ( $i = 1; $i < count( $fields ); $i += 2 ) {
                $fieldname = $fields[ $i ];
                if ( strpos( $fields[ $i + 1 ], "[[[" ) === FALSE ) {
                    $value = trim( str_replace( "(((", "", $fields[ $i + 1 ]) );
                }
                else {
                    $sub_value = "";
                    $sub_fields = explode( "[[[", $fields[ $i + 1 ] );
                    for ( $j = 1; $j < count( $sub_fields ); $j += 2 ) {
                        if ( $j != 1 && ! empty( $sub_fields[ $j + 1 ] ) ) {
                            $sub_value .= " | ";
                        }
                        $sub_value .= trim( str_replace( "(((", "", $sub_fields[ $j + 1 ] ) );
                    }
                    $value = $sub_value;
                }
                if ( ! empty($value) ) {
                    assign_bib_array($bib, $fieldname, $value );
                }
            }
            return $bib;
    }
    else {
        return FALSE;
    }
}


/*  Function: json_extract(& )
 *
 *  Get the JSON into something we can display
 *  Pass by reference to speed up recursion.
 *
 */
function json_extract( &$barr) {
    $bib_fields = bib_field_array();
    $book_html = "";
    // loop through array struture recursively
    foreach ($barr as $key => $value) {
  //      if ( /*in_array($key,$bib_fields) ||*/ TRUE || is_int($key) ) {
            if ( ! is_array($value) && $value != ""  ) {
                $effective_key = is_int($key) ? '[[[///' . $key . '[[[' : '|||' . $key . '|||';
                $book_html .= "$effective_key ((($value(((";
            }
            else {
                if ( is_array( $value ) ) {
                    $sub_bib = json_extract($value, $bib_fields);
                }
                else {
                    $sub_bib = $value;
                }
                if ( $sub_bib != "" ) {
                        $book_html .= "|||" . $key . "|||" . $sub_bib . "";
                }
            }
   //     }
    }
    return $book_html;
}


/*  Function: extract_from_string_by_key
 *
 *  Get a bib value from the string
 *
 */
function extract_from_string_by_key( $bib_str, $find ) {
   $field_arr = explode("|||", $bib_str);
   $found_index = array_search($find, $field_arr);
   if ( $found_index === FALSE ) {
       return FALSE;
   }
   $found_str = $field_arr[ $found_index + 1 ];
   return str_replace("(((", "", $found_str);
}


function assign_bib_array( & $bib_array, $index, $value ) {
    if ( ! array_key_exists( $index, $bib_array ) ) {
        $bib_array[ $index ] = $value;
    }
    else {
        $bib_array[ $index ] = $bib_array[ $index ] . " | " . $value;
    }
}


/**
* Get the URL contents
*/
function get_url_contents($url, $curltimeout) {

    // Establish a cURL handle.
    $ch = curl_init($url);

    // curl Options
    curl_setopt($ch, CURLOPT_HEADER, FALSE); //false=do not include headers
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE); //true=return as string
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, $curltimeout); //timeout for when OL is down
    curl_setopt($ch, CURLOPT_TIMEOUT, $curltimeout); //timeout for when OL is down

    // Execute the request
    $output = curl_exec($ch);

    // Close the cURL session.
    curl_close($ch);

    if ($output == "") {
        throw new Exception("Google Books Data Currently Unavailable");
    }
    return $output;
}


function googlebook_get_content($key) {
  $path = $key .'.json';
  return _googlebook_cached_request($path);
}


function _googlebook_cached_request($path) {

    // build the full path (and the cache key)
    $url_bookkeys = GOOGLE_BOOKS_API_ROOT . $path ;

    // See if it is cached
    $cached = cache_get( $url_bookkeys, 'cache_googlebook' );

    // If is it IS cached, then just return the data from the cache.
    if ( $cached !== FALSE ) {
        // Check if the time has expired
        if ($cached->expire < time()) {
            cache_clear_all( $url_bookkeys, 'cache_googlebook' );
        }
    return $cached->data;
    }
    else {
        // Do it the slow way, go get the new data
        $bookkeys = get_url_contents($url_bookkeys, CURLTIMEOUT);

        // Set the cache
        cache_set($url_bookkeys, $bookkeys, 'cache_googlebook', time() + OPENLIBRARY_CACHE_PERIOD);

        // Bookkeys is the data, so return it
        return $bookkeys;
    }
}
